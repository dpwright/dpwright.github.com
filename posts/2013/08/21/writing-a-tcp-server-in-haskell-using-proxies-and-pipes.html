<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Wright Access - Writing a TCP server in Haskell using proxies and pipes</title>
        <link rel="stylesheet" type="text/css" href="../../../../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../../../../css/syntax.css" />
        <link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.css" />
        <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-35158763-1', 'auto');
          ga('send', 'pageview');
        </script>
    </head>
    <body>
        <div id="header">
            <div id="logo">
             <h1 id="logomain"><a href="../../../../">Wright Access.</a></h1>
            </div>
            <div id="navigation">
                <a href="../../../../pages/about"><i class="fa fa-question-circle"></i></a>
            </div>
        </div>

        <div id="content">
            <div id="titlematter">
              
                <h1 class="title">Writing a TCP server in Haskell using proxies and pipes</h1>
              
              
            </div>

            <div id="mainmatter">
              <div class="info">21 August, 2013</div>

<div id="crosspost">
<p>This is a cross-post of an article originally written for the <a href="http://blog.vitei.com/">Vitei Backroom Blog</a>.<br />
Read the original article <a href="http://blog.vitei.com/?p=147">here</a>.</p>
</div>


<center>
<img src="http://blog.vitei.com/wp-content/uploads/2013/08/haskell-pipes2.jpg" alt="Haskell Pipes" />
</center>
<div class="sidenote">
Since the release of <a href="http://hackage.haskell.org/package/pipes-4.0.0">Pipes 4</a>, this article is now rather out-of-date. I leave it up here for posterity, but if you’re new to Pipes you should probably just ignore it and find a more up-to-date tutorial.
</div>
<p>Since my last post, I’ve really been enjoying Haskell, and in fact a lot of the functional ideas I had formerly been playing with in Clojure I am now exploring in Haskell instead. I will go into more detail on the reasons for that in a future post – for now I just wanted to share a neat bit of code I wrote the other day that I think really demonstrates the kind of concise, readable code Haskell enables.</p>
<div>

</div>
<!--more-->
<h2 id="problem-description">Problem description</h2>
<p>This is a really simple, common requirement: the application requires a TCP server to take requests and perform whatever it is the application does, after which it will respond with some sort of output. Everyone’s had to do it at some point, and there’s a range of ways to implement it – from the hack-it-in-quick interface to some simple utility to the robustness of, say, a web server.</p>
<p>My requirements were fairly rudimentary, and so this implementation is a pretty simple one. Still, maybe it’ll be a useful starting-point for anyone who wants to get a server up and running quickly.</p>
<p>The input to the server is a series of single-line commands separated by Windows-style <code>\r\n</code> newlines. In response to each of these commands, the server will respond with potentially multiple lines, completed by the special terminator string: <code>\r\nEND\r\n\r\n</code>.</p>
<h2 id="setting-up">Setting up</h2>
<p>This server is built around the <code>pipes</code> package, a very nicely-designed framework which allow you to stream data through some sort of pipeline. The <code>pipes-network</code> package, originally written by Paolo Capriotti and now maintained by Renzo Carbonara, provides some useful <code>Producer</code> and <code>Pipe</code> functions which read from and write to a TCP socket respectively, so a lot of the work has already been done for us. Before we start, we will need to install the <code>pipes-network</code> package:</p>
<div class="elastic-tabstops">
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="ex">cabal</span> install pipes-network</code></pre></div></td>
</tr>
</tbody>
</table>
</div>
<p><code>pipes-network</code> delivers and expects to receive its data in <code>ByteString</code> form, rather than a plain <code>String</code>. I wanted to work with <code>Text</code> in my own code. This mix of three different string types can get quite confusing, and I really don’t want to clutter up my code with lots of conversions of literal strings, so let’s make use of the <code>OverloadedStrings</code> LANGUAGE pragma to perform those conversions for us:</p>
<div class="elastic-tabstops">
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></code></pre></div></td>
</tr>
</tbody>
</table>
</div>
<p>This won’t help us when it comes to converting the actual strings we’re working with, but at least it’ll make literal strings in the code look a bit tidier.</p>
<p>Finally, let’s import the modules we need:</p>
<div class="elastic-tabstops">
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Network</span></code></pre></div></td>
</tr>
<tr class="even">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"></code></pre></div></td>
</tr>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Proxy</span></code></pre></div></td>
</tr>
<tr class="even">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Proxy.TCP</span></code></pre></div></td>
</tr>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"></code></pre></div></td>
</tr>
<tr class="even">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Monad</span></code></pre></div></td>
</tr>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.List</span></code></pre></div></td>
</tr>
<tr class="even">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Maybe</span></code></pre></div></td>
</tr>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"></code></pre></div></td>
</tr>
<tr class="even">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></code></pre></div></td>
</tr>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Text.Encoding</span></code></pre></div></td>
</tr>
<tr class="even">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Text.Encoding.Error</span></code></pre></div></td>
</tr>
</tbody>
</table>
</div>
<p>These should mostly be fairly self-explanatory. We are dealing with network code, so the <code>Network</code> module provides some types (such as <code>Socket</code>) which are going to be useful to us. <code>Control.Proxy</code> and <code>Control.Proxy.TCP</code> are provided by the aforementioned <code>pipes</code> and <code>pipes-network</code> modules respectively. <code>Control.Monad</code> and <code>Data.List</code> provide various useful utilities. Finally, the last three imports handle our various string formats. For my purposes, I am assuming all interaction with the server will be in UTF-8, and I make use of <code>Data.Text.Encoding</code> to convert to and from <code>ByteString</code>.</p>
<h2 id="structure-and-types">Structure and Types</h2>
<p>OK, so now we’re set up, how is the server going to work, and how is the rest of our program going to interface with it? I wanted the server to be as simple as possible, and really I just wanted to set it running and then just forget about it, and let the rest of my program handle commands as they come in. I decided I would accept two functions from my program, one to interpret incoming text (guaranteed to be a single line) and turn it into some command format the program understood, and another to read in these commands and perform some action, returning any output from running that action.</p>
<p>The interpreter is a simple, pure function, which simply maps <code>Text</code> to some command type <code>c</code> (defined by the program):</p>
<div class="elastic-tabstops">
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Interpreter</span> c <span class="fu">=</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> c</code></pre></div></td>
</tr>
</tbody>
</table>
</div>
<p>The handler is slightly more involved. Firstly, I didn’t want it to have to worry about the terminator string, so I would have the server add those itself. This posed a problem though: since the output could potentially be multiple lines, and the action could take a long time to complete, I wanted to stream it out to the socket as it came in, not all in one chunk at the end. But in order to do this, I would have to know whether or not to add the terminator string for a particular piece of output, as it should only be added at the very end. My handler, then, would need to output some information about whether or not it was complete, along with whatever text it needed to deliver so far. This can be accomplished with the following type:</p>
<div class="elastic-tabstops">
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Output</span> t <span class="fu">=</span> <span class="dt">Still</span> t</code></pre></div></td>
</tr>
<tr class="even">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>               <span class="fu">|</span> <span class="dt">Done</span> t</code></pre></div></td>
</tr>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>               <span class="kw">deriving</span> (<span class="dt">Show</span>)</code></pre></div></td>
</tr>
</tbody>
</table>
</div>
<p>Onto the handler itself then! This is the first instance of one of the types defined by the <code>pipes</code> library, a <code>Pipe</code>. A <code>Pipe</code> is a generalization of the <code>Proxy</code> typeclass defined by the library, which defines a set of types which can send and/or receive data up or downstream. The library defines various instances of these. They are explained in excellent detail in the <a href="http://hackage.haskell.org/packages/archive/pipes/3.3.0/doc/html/Control-Proxy-Tutorial.html#g:3">Control.Proxy Tutorial</a>, but in summary:</p>
<ul>
<li>A <code>Producer</code> generates values to be streamed <em>downstream</em></li>
<li>A <code>Consumer</code> reads values from <em>upstream</em></li>
<li>A <code>Pipe</code> reads values <em>upstream</em> and then sends values <em>downstream</em> (think of it like a UNIX pipe, where “upstream” is equivalent to reading from <code>STDIN</code> and “downstream” is equivalent to writing to <code>STDOUT</code>)</li>
<li>A <code>Client</code> can send and receive values <em>upstream</em></li>
<li>A <code>Server</code> can send and receive values <em>downstream</em></li>
<li>A <code>Proxy</code> can both send and receive values in either direction</li>
<li>Finally, a <code>Session</code> is formed by composing <code>Producers</code>, <code>Pipes</code>, and <code>Consumers</code>, or by composing <code>Clients</code>, <code>Proxies</code>, and <code>Servers</code>. A <code>Session</code> is a closed system; it has no upstream or downstream interface.</li>
</ul>
<p>Our command handler, then, is expected to read in commands from the interpreter <em>upstream</em> and send its output to the socket <em>downstream</em> – look at the list above again and it should be quite obvious that it is a <code>Pipe</code>! Thus, our <code>Handler</code> definition:</p>
<div class="elastic-tabstops">
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Handler</span> c <span class="fu">=</span> () <span class="ot">-&gt;</span> <span class="dt">Pipe</span> <span class="dt">ProxyFast</span> c (<span class="dt">Output</span> <span class="dt">T.Text</span>) <span class="dt">IO</span> ()</code></pre></div></td>
</tr>
</tbody>
</table>
</div>
<p>As we can see, <code>Handler</code> is a function which returns a <code>Pipe</code> from some command type <code>c</code> (as output by the <code>Interpreter</code>), to a <code>Text</code> value wrapped in our <code>Output</code> type. It exists in the <code>IO</code> monad as it will need to perform an action. Finally, it receives and outputs <code>()</code> – these values are used for requests from downstream and requests sent upstream, neither of which are supported by <code>Pipe</code>.</p>
<p>There’s one annoyance here which I haven’t managed to solve – I am specifying the proxy <code>ProxyFast</code> rather than just accepting any type of class <code>Proxy</code>. I tried doing the latter, but I couldn’t get it to typecheck correctly – I think because my use of <code>runProxy</code> later forces the server to run under <code>ProxyFast</code>, so if a user tried to pass in a handler of type <code>ProxyCorrect</code>, it wouldn’t be compatible. This seems quite reasonable, but it is nevertheless annoying that this information about which proxy implementation I am using must leak out of the module. The solution is probably to have my handler not implemented as a proxy, but instead provide it with some interface to which it can send incremental output (perhaps a <code>TChan</code>). This would mean the client program need not deal with proxies or the <code>pipes</code> library at all! It complicates the code somewhat, though, so for now I will use the above interface.</p>
<h2 id="main-server-backend">Main Server Backend</h2>
<p>Now our types are in place, we’re almost there! Let’s make a simple function to start our server up and set it running first, which I’ll call <code>run</code>:</p>
<div class="elastic-tabstops">
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; run ::</span> <span class="dt">Interpreter</span> c <span class="ot">-&gt;</span> <span class="dt">Handler</span> c <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</code></pre></div></td>
</tr>
<tr class="even">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> run interpreter handler port <span class="fu">=</span> serve <span class="dt">HostAny</span> port go</code></pre></div></td>
</tr>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>   <span class="kw">where</span> go (socket,_) <span class="fu">=</span> runProxy <span class="fu">$</span> server interpreter handler socket</code></pre></div></td>
</tr>
</tbody>
</table>
</div>
<p><code>run</code> is our interface to the rest of the program – we start the server up with this function, passing in our interpreter and handler functions, as well as the port we want to run on. It uses <code>pipes-network</code> to start up the server and then run our <code>Proxy</code> for each incoming connection, passing the functions through as well as the socket to communicate on.</p>
<p><code>runProxy</code> expects a function taking <code>()</code> and returning the proxy we want to run. In addition to this, we want to feed the <code>Interpreter</code>, <code>Handler</code>, and active <code>Socket</code> to the proxy to work with. The type signature for our <code>server</code> function, therefore, must be:</p>
<div class="elastic-tabstops">
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; server ::</span> <span class="dt">Interpreter</span> c <span class="ot">-&gt;</span> <span class="dt">Handler</span> c <span class="ot">-&gt;</span> <span class="dt">Socket</span> <span class="ot">-&gt;</span> () <span class="ot">-&gt;</span> <span class="dt">Session</span> <span class="dt">ProxyFast</span> <span class="dt">IO</span> ()</code></pre></div></td>
</tr>
</tbody>
</table>
</div>
<p>One thing I love about Haskell is how easy it is to work top-down; you can start with a rough outline of what you want to get done and then fill in the blanks later. Here is the implementation of <code>server</code>, which can be expressed as a composition of proxies representing each part of the process:</p>
<div class="elastic-tabstops">
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> server i h s <span class="fu">=</span> readSocket <span class="fu">&gt;-&gt;</span> interpret <span class="fu">&gt;-&gt;</span> handle <span class="fu">&gt;-&gt;</span> writeSocket</code></pre></div></td>
</tr>
</tbody>
</table>
</div>
<p>This is the sort of expressive power the <code>pipes</code> library gives us – it almost reads like an ASCII diagram describing the required server behaviour! It only remains for us to “fill in the blanks” by defining each of these functions. We can do this in a <code>where</code> clause, and for the most part, each part of the session is itself a composition of simple proxies. I’m going to work from the outside in, beginning with the administrivia of reading data in from the socket and writing results back out to it, and then dealing with the actual interpretation and handling of data at the end. We’ll begin with reading in data from the socket:</p>
<div class="elastic-tabstops">
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>   <span class="kw">where</span></code></pre></div></td>
</tr>
<tr class="even">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     readSocket <span class="fu">=</span> socketReadS <span class="dv">4096</span> s <span class="fu">&gt;-&gt;</span> decode <span class="fu">&gt;-&gt;</span> split <span class="st">&quot;\r\n&quot;</span></code></pre></div></td>
</tr>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     decode <span class="fu">=</span> mapD <span class="fu">$</span> decodeUtf8With lenientDecode</code></pre></div></td>
</tr>
</tbody>
</table>
</div>
<p><code>readSocket</code> reads data in from the socket using a <code>Producer</code> defined by the <code>pipes-network</code> library. The number <code>4096</code> is just that recommended for general purposes by the library – it might need tweaking depending on your needs. <code>decode</code> reads in raw <code>ByteStrings</code> and converts them to UTF-8 encoded <code>Text</code> data. <code>mapD</code> is a utility function provided by <code>pipes</code> which will take a pure function and generate a <code>Pipe</code> which pipes everything it receives from upstream through the function and sends the results downstream. Finally <code>split</code> is a <code>Pipe</code> which buffers up text it receives from upstream until it reaches a certain delimiter, at which point it sends the text up to and including the delimiter downstream – its definition appears later.</p>
<p>Writing the data back out is pretty similar – we receive UTF-8 <code>Text</code> and we want to encode it as a <code>ByteString</code> before sending it out through the socket. This time, though, we don’t care about buffering – we can just send text out as it comes in – so we can omit the call to <code>split</code>:</p>
<div class="elastic-tabstops">
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     writeSocket <span class="fu">=</span> mapD encodeUtf8 <span class="fu">&gt;-&gt;</span> socketWriteD s <span class="fu">&gt;-&gt;</span> done</code></pre></div></td>
</tr>
</tbody>
</table>
</div>
<p>The reason for the <code>done</code> at the end there is that it turns out that <code>socketWriteD</code> pipes any data it writes to the socket downstream, to ease composition. In order to close off our session, we need a <code>Consumer</code> which will sit there forever, taking data from upstream and ignoring it. Strictly speaking this isn’t necessary, but it allows us to treat our server as a <code>Session</code> rather than a <code>Producer</code>. Its definition is as follows:</p>
<div class="elastic-tabstops">
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     done () <span class="fu">=</span> forever <span class="fu">$</span> request () <span class="fu">&gt;&gt;</span> return ()</code></pre></div></td>
</tr>
</tbody>
</table>
</div>
<p>We should now have UTF-8 encoded <code>Text</code> data being pumped out, line-by-line, to the interpreter, and we are expecting to get <code>Text</code> data back out from the <code>handle</code> function to send on down the pipe. Time to call back out to our application’s interpreter and handler.</p>
<p>Remember we defined the interpreter as a pure function taking in <code>Text</code> and spitting out <code>Commands</code>? <code>interpret</code>, then, merely needs to convert this pure function into a <code>Pipe</code>, using <code>mapD</code> again:</p>
<div class="elastic-tabstops">
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     interpret <span class="fu">=</span> mapD i</code></pre></div></td>
</tr>
</tbody>
</table>
</div>
<p>The handler has the small extra complication of needing to append our terminator string whenever the application tells us it is <code>Done</code>. We can do this by composing the handler function (which is already a pipe) with a small utility function:</p>
<div class="elastic-tabstops">
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     terminator <span class="fu">=</span> <span class="st">&quot;\r\nEND\r\n\r\n&quot;</span></code></pre></div></td>
</tr>
<tr class="even">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     handle <span class="fu">=</span> h <span class="fu">&gt;-&gt;</span> mapD handleOutput</code></pre></div></td>
</tr>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     handleOutput (<span class="dt">Still</span> t) <span class="fu">=</span> t</code></pre></div></td>
</tr>
<tr class="even">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     handleOutput (<span class="dt">Done</span> t) <span class="fu">=</span> t <span class="ot">`T.append`</span> terminator</code></pre></div></td>
</tr>
</tbody>
</table>
</div>
<p>That’s it! That’s basically all we need to define a simple, streams-based server. Now all our application needs to do is define an <code>Interpreter</code> and a <code>Handler</code>, and we’re on our merry way! Well… almost. We still haven’t defined the <code>split</code> function.</p>
<h2 id="buffering-text">Buffering Text</h2>
<p>Our <code>readSocket</code> proxy runs its output through a proxy called <code>split</code> at the end, in order to buffer up the text it receives and send it out broken apart by newlines. I was surprised not to find something like this defined in <code>pipes-network</code> already – perhaps it is there and I missed it. At any rate, I wrote a definition of it here – the only <code>Pipe</code> in the server code which is not simply a composition of other proxies. I am pretty certain there must be a better way to do this, and it’s probably a DDOS risk (you could stream it a huge line without any linefeeds and it would keep buffering until it ran out of memory), but it served my purposes. Comments on better ways to achieve this would be much appreciated!</p>
<p><code>split</code> takes the delimiter to split on and returns a <code>Pipe</code> function, which runs a loop passing in the current state of the buffer as its parameter. It starts, of course, with the empty buffer:</p>
<div class="elastic-tabstops">
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; split ::</span> <span class="dt">Proxy</span> p <span class="ot">=&gt;</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> () <span class="ot">-&gt;</span> <span class="dt">Pipe</span> p <span class="dt">T.Text</span> <span class="dt">T.Text</span> <span class="dt">IO</span> ()</code></pre></div></td>
</tr>
<tr class="even">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> split d () <span class="fu">=</span> runIdentityP <span class="fu">$</span> loop T.empty</code></pre></div></td>
</tr>
</tbody>
</table>
</div>
<p><code>runIdentityP</code> there is provided by <code>pipes</code> and helps Haskell infer the types better.</p>
<p>The loop itself begins by requesting the latest data from upstream, and appending it to our existing buffer:</p>
<div class="elastic-tabstops">
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>   <span class="kw">where</span></code></pre></div></td>
</tr>
<tr class="even">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     loop r <span class="fu">=</span> <span class="kw">do</span></code></pre></div></td>
</tr>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>       a <span class="ot">&lt;-</span> request ()</code></pre></div></td>
</tr>
<tr class="even">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>       <span class="kw">let</span> a' <span class="fu">=</span> r <span class="ot">`T.append`</span> a</code></pre></div></td>
</tr>
</tbody>
</table>
</div>
<p>We then check whether the delimiter can be found in the newly received text, and if it can we split the entire buffer on the delimiter, send the first part (up to the first delimiter) downstream, and pass the remainder back to the next iteration of the loop. If the delimiter can’t be found, we just loop again with the updated contents of the buffer:</p>
<div class="elastic-tabstops">
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>       <span class="kw">if</span> d <span class="ot">`T.isInfixOf`</span> a</code></pre></div></td>
</tr>
<tr class="even">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>         <span class="kw">then</span> <span class="kw">do</span></code></pre></div></td>
</tr>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>           <span class="kw">let</span> l <span class="fu">=</span> T.splitOn d a'</code></pre></div></td>
</tr>
<tr class="even">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>           forM_ (init l) respond</code></pre></div></td>
</tr>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>           loop <span class="fu">$</span> last l</code></pre></div></td>
</tr>
<tr class="even">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>         <span class="kw">else</span> loop a'</code></pre></div></td>
</tr>
</tbody>
</table>
</div>
<p>This implementation is OK and it does the job, but I am not totally happy with it. Apart from the obvious issue that it could buffer the text forever, it just doesn’t “look nice”. My experience with functional programming so far has taught me that if things don’t look nice, they probably aren’t – there is usually a more elegant, functional way to do them. I may revisit it in future.</p>
<h2 id="interacting-with-our-server">Interacting with our server</h2>
<p>In a couple of compact functions, we have a fully-working TCP server! Let’s write the application-side code to make use of it. Since this is a single blog post, we’ll just write the application code inline – of course usually you’d put the server stuff in a module and import it into your application. Consider this the cut-off point – everything before this paragraph belongs in a module; everything after it is application code and can go in your <code>Main</code> module or anywhere else.</p>
<p>Our application will need to work with some sort of command type – this defines all the actions that our handler knows how to take. Let’s keep it simple and support just three commands: “add”, “echo” and “quit”. If the server receives anything else it should respond with “Unrecognised command”.</p>
<p>“add” will take as its input a list of integers and return the result of adding them together as its output. “echo” will simply echo the text back out. “quit” will disconnect the client. These commands can be defined as follows:</p>
<div class="elastic-tabstops">
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Command</span> <span class="fu">=</span> <span class="dt">Add</span> [<span class="dt">Integer</span>]</code></pre></div></td>
</tr>
<tr class="even">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>              <span class="fu">|</span> <span class="dt">Echo</span> <span class="dt">T.Text</span></code></pre></div></td>
</tr>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>              <span class="fu">|</span> <span class="dt">Quit</span></code></pre></div></td>
</tr>
<tr class="even">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>              <span class="fu">|</span> <span class="dt">Unknown</span> <span class="dt">T.Text</span></code></pre></div></td>
</tr>
</tbody>
</table>
</div>
<p>Firstly we’ll write our interpreter. Of course there’s all sorts of things you could do here – parsing text is one of Haskell’s great strengths! But all I really want is to put the command, followed by a space, followed by its parameters, separated by spaces. A proper interpreter would need to handle syntax/type errors and the like, but for the sake of simplicity I will assume only valid input can be received:</p>
<div class="elastic-tabstops">
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; interpreter ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">Command</span></code></pre></div></td>
</tr>
<tr class="even">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> interpreter <span class="fu">=</span> interpret <span class="fu">.</span> T.words</code></pre></div></td>
</tr>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>   <span class="kw">where</span></code></pre></div></td>
</tr>
<tr class="even">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     interpret (<span class="st">&quot;add&quot;</span><span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Add</span> <span class="fu">$</span> map (safeRead <span class="dv">0</span>) xs</code></pre></div></td>
</tr>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     interpret (<span class="st">&quot;echo&quot;</span><span class="fu">:</span>text) <span class="fu">=</span> <span class="dt">Echo</span> <span class="fu">$</span> T.unwords text</code></pre></div></td>
</tr>
<tr class="even">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     interpret (<span class="st">&quot;quit&quot;</span><span class="fu">:</span>[]) <span class="fu">=</span> <span class="dt">Quit</span></code></pre></div></td>
</tr>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     interpret other <span class="fu">=</span> <span class="dt">Unknown</span> <span class="fu">$</span> T.unwords other</code></pre></div></td>
</tr>
</tbody>
</table>
</div>
<p>The inclusion of <code>[]</code> at the end of the deconstruction of “quit” means that strings such as “quit with extra text at the end” will return “Unrecognised command” rather than quitting.</p>
<p><code>safeRead</code> is our nod toward handling unexpected input. Usually, if <code>read</code> receives a string that can’t be parsed as the type we’re looking for (<code>Integer</code> in our case), it will throw an exception. What we’re going to do here is just ignore it by returning the default value of <code>0</code>. Its implementation is as follows:</p>
<div class="elastic-tabstops">
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     safeRead defval x <span class="fu">=</span> maybe defval id (readMaybe x)</code></pre></div></td>
</tr>
<tr class="even">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     readMaybe <span class="fu">=</span> fmap fst <span class="fu">.</span> listToMaybe <span class="fu">.</span> reads <span class="fu">.</span> T.unpack</code></pre></div></td>
</tr>
</tbody>
</table>
</div>
<p>Note that <code>readMaybe</code> is actually included as part of <code>Text.Read</code> in GHC versions 7.6 and above, so its definition may not be required. I include it here to support older versions of the compiler.</p>
<p>Next up is our command handler. In order to have access to the <code>respond</code> function to pipe output downstream, we have to implement this as a <code>Pipe</code>. For those commands which simply take a simple input and return a simple response, though, it would be nicer to define them as a simpler mapping of the form:</p>
<div class="elastic-tabstops">
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; command ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Command</span> <span class="ot">-&gt;</span> m <span class="dt">T.Text</span></code></pre></div></td>
</tr>
</tbody>
</table>
</div>
<p>In fact, neither of our currently-defined commands require access to any monad, but we will define <code>command</code> in those terms since in the real world it’s very likely that we <em>will</em> want access to <code>IO</code> or <code>STM</code> or something similar in order to communicate requests to other parts of the application.</p>
<p>Let’s define our currently supported commands in terms of this simpler interface:</p>
<div class="elastic-tabstops">
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> command (<span class="dt">Echo</span> t) <span class="fu">=</span> return t</code></pre></div></td>
</tr>
<tr class="even">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> command (<span class="dt">Add</span> xs) <span class="fu">=</span> return <span class="fu">$</span> (T.pack <span class="fu">.</span> show) <span class="fu">$</span> foldl' (<span class="fu">+</span>) <span class="dv">0</span> xs</code></pre></div></td>
</tr>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> command (<span class="dt">Unknown</span> cmd) <span class="fu">=</span> return <span class="fu">$</span> <span class="st">&quot;Unrecognised command: &quot;</span> <span class="ot">`T.append`</span> cmd</code></pre></div></td>
</tr>
</tbody>
</table>
</div>
<p>Our handler itself, then, will be a dispatcher, which can send commands to the appropriate handler if one exists, or pass them off to this simple handler otherwise:</p>
<div class="elastic-tabstops">
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; commandDispatcher ::</span> <span class="dt">Proxy</span> p <span class="ot">=&gt;</span> () <span class="ot">-&gt;</span> <span class="dt">Pipe</span> p <span class="dt">Command</span> (<span class="dt">Output</span> <span class="dt">T.Text</span>) <span class="dt">IO</span> ()</code></pre></div></td>
</tr>
<tr class="even">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> commandDispatcher () <span class="fu">=</span> runIdentityP loop <span class="kw">where</span></code></pre></div></td>
</tr>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>   loop <span class="fu">=</span> <span class="kw">do</span></code></pre></div></td>
</tr>
<tr class="even">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     cmd <span class="ot">&lt;-</span> request ()</code></pre></div></td>
</tr>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>     <span class="kw">case</span> cmd <span class="kw">of</span></code></pre></div></td>
</tr>
<tr class="even">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>       <span class="dt">Quit</span> <span class="ot">-&gt;</span> respond (<span class="dt">Done</span> <span class="st">&quot;GOODBYE&quot;</span>) <span class="fu">&gt;&gt;</span> return ()</code></pre></div></td>
</tr>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>       _    <span class="ot">-&gt;</span> executeSimple cmd <span class="fu">&gt;&gt;</span> loop</code></pre></div></td>
</tr>
<tr class="even">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span>   executeSimple cmd <span class="fu">=</span> (lift <span class="fu">.</span> command) cmd <span class="fu">&gt;&gt;=</span> respond <span class="fu">.</span> <span class="dt">Done</span></code></pre></div></td>
</tr>
</tbody>
</table>
</div>
<p>This function loops until it receives the <code>Quit</code> command, at which point it breaks out of the loop which causes the entire <code>Session</code> to be dismantled, disconnecting the client.</p>
<p>Finally, we add a <code>main</code> function to set it all in motion on port “8000”. The call to <code>withSocketsDo</code> is required on Windows, and is a no-op on other systems, so it’s good form to use it whenever we’re dealing with network code:</p>
<div class="elastic-tabstops">
<table>
<colgroup>
<col width="100%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; main ::</span> <span class="dt">IO</span> ()</code></pre></div></td>
</tr>
<tr class="even">
<td align="left"><div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> main <span class="fu">=</span> withSocketsDo <span class="fu">$</span> run interpreter commandDispatcher <span class="st">&quot;8000&quot;</span></code></pre></div></td>
</tr>
</tbody>
</table>
</div>
<p>If you copy and paste this page into a file and run it with <code>runhaskell</code> you should be able to open another window and telnet into <code>localhost</code> on port 8000. Try typing some commands and see what happens!</p>

<div class="tagsinfo">Tagged with: <a href="../../../../tags/literate-programs">literate-programs</a>, <a href="../../../../tags/haskell">haskell</a>, <a href="../../../../tags/functional-programming">functional-programming</a></div>

            </div>
        </div>
        <div id="footer">
          <div id="text-licence">
            <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br />
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" property="dct:title" rel="dct:type">Wright Access</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="http://dpwright.com/" property="cc:attributionName" rel="cc:attributionURL">Daniel P. Wright</a> is licensed under a<br />
            <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.
          </div>
          <br />
          <div id="code-licence">
            All code is released under the <a href="../../../../pages/about#simplified-bsd-2-clause-license">BSD (2-Clause) License</a>.
          </div>
        </div>
    </body>
</html>
