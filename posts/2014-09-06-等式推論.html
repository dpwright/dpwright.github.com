<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Wright Access - 等式推論</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
        <link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.css" />
        <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
    </head>
    <body>
        <div id="header">
            <div id="logo">
             <h1 id="logomain"><a href="../">Wright Access</a></h1>
             <h2 id="sublogo">dpwright's notes on code, Japan, Japanese, and anything else</h2>
             <div id="social">
                 <a class="icon" href="http://github.com/dpwright"><i class="fa fa-github"></i></a>
                 <a class="icon" href="http://twitter.com/danielpwright"><i class="fa fa-twitter"></i>en</a>
                 <a class="icon" href="http://twitter.com/tataminomusi"><i class="fa fa-twitter"></i>jp</a>
                 <a class="icon" href="mailto:dani@dpwright.com"><i class="fa fa-envelope-o"></i></a>
                 <a class="icon" href="../atom.xml"><i class="fa fa-rss-square"></i></a>
              </div>
            </div>
            <div id="navigation">
                <a href="../tags/functional-programming.html">λ</a>
                <a href="../tags/git.html"><i class="fa fa-code-fork"></i></a>
                <a id="vim-icon" href="../tags/vim.html">:w</a>
                <span id="jp-icon"><a href="../tags/日本語.html">日</a></span>
                <a href="../pages/about.html"><i class="fa fa-question-circle"></i></a>
            </div>
        </div>

        <div id="content">
            <h1 class="title">等式推論</h1>

            <div class="info"> 6 September, 2014</div>



<h2 id="自己紹介">自己紹介</h2>
<ul>
<li><i class="fa fa-twitter"></i> <a href="http://twitter.com/tataminomusi">@tataminomusi</a> （日本語）</li>
<li><i class="fa fa-twitter"></i> <a href="http://twitter.com/danielpwright">@danielpwright</a> （英語）</li>
<li><i class="fa fa-github"></i> <a href="http://github.com/dpwright">dpwright</a></li>
<li>京都のゲーム会社、VITEIのリードプログラマー</li>
<li>基本的にC++、でもツール等は多言語
<ul>
<li>ビルドシステムはRubyとNinja</li>
<li>MayaプラグインはPython</li>
<li>コンパイラはHaskell</li>
<li>C#のツールもあります</li>
</ul></li>
<li>ホントはHaskellでゲームを作ってみたいけどまだまだ難しい</li>
</ul>
<h2 id="このセッション">このセッション</h2>
<p>. . .</p>
<h3 id="どの言語に向いてる">どの言語に向いてる？</h3>
<ul>
<li>💖 Haskell 💕</li>
<li>依存型言語：Agda, Idris, Coq…</li>
<li>ML系：SML, Ocaml, F#…</li>
<li>Scala？</li>
<li>Lisp系？</li>
<li>C++/Java/Pascal/BASIC…?!</li>
</ul>
<div class="notes">
<p>大事な機能は：</p>
<ul>
<li>参照透過性</li>
<li>置換モデル</li>
<li>純粋関数</li>
<li>シンタックス</li>
</ul>
</div>
<h3 id="どのレベル">どのレベル？</h3>
<h2 id="文芸的プログラミング">文芸的プログラミング</h2>
<p>このスライド自体をコンパイルして実行できる！</p>
<p>. . .</p>
<p>Haskellの基本関数を再定義するつもりなんで、とりあえず隠さないと</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (sum, foldr, sequence_, replicate, take, repeat)</code></pre>
<h2 id="等式推論" class="titlepage">等式推論</h2>
<p>. . .</p>
<h3 id="はいったい何ですか">は、いったい何ですか？！</h3>
<h2 id="例変数置換">例　変数置換</h2>
<p>基本的に、中学校で代数学を勉強したときの変数置換と近い</p>
<p>. . .</p>
<p><span class="math">\[
\begin{align}
x &amp;= 49       \\
y &amp;= x + 1000 \\
              \\
y &amp;= 1049
\end{align}
\]</span></p>
<h2 id="例連立方程式">例　連立方程式</h2>
<p><span class="math">\[
\begin{align}
2x + y &amp;= 4 \\
x - y  &amp;= -1
\end{align}
\]</span></p>
<p>方程式を組み替えたら同じ方法で解けます</p>
<p>. . .</p>
<p><span class="math">\[
\begin{align}
y &amp;= 4 - 2x \\
x &amp;= y - 1
\end{align}
\]</span></p>
<h2 id="例連立方程式-1">例　連立方程式</h2>
<table>
<colgroup>
<col width="30%" />
<col width="30%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><p><span class="math">\[
\begin{align}
x  &amp;= y - 1        \\
   &amp;= (4 - 2x) - 1 \\
   &amp;= 3 - 2x       \\
3x &amp;= 3            \\
x  &amp;= 1            \\
\end{align}
\]</span></p></td>
<td align="left"><p><span class="math">\[
\begin{align}
y  &amp;= 4 - 2x       \\
   &amp;= 4 - 2(y - 1) \\
   &amp;= 4 - 2y + 2   \\
3y &amp;= 6            \\
y  &amp;= 2
\end{align}
\]</span></p></td>
</tr>
</tbody>
</table>
<h2 id="例数学的証明">例　数学的証明</h2>
<p>「黄金数」と呼ばれる　<span class="math">\(\phi = \frac{1 + \sqrt{5}}{2}\)</span></p>
<p><span class="math">\(\phi^2 = \phi + 1\)</span>　を証明せよ</p>
<h2 id="例数学的証明-1">例　数学的証明</h2>
<p><span class="math">\[
\begin{align}
\phi^2 &amp;= \frac{1 + \sqrt{5}}{2} \times \frac{1 + \sqrt{5}}{2} \\
       &amp;= \frac{(1 + \sqrt{5})(1 + \sqrt{5})}{4}               \\
       &amp;= \frac{1 + \sqrt{5} + \sqrt{5} + \sqrt{5}^2}{4}       \\
       &amp;= \frac{6 + 2(\sqrt{5})}{4}                            \\
       &amp;= \frac{3 + \sqrt{5}}{2} = \frac{2}{2} + \frac{1 + \sqrt{5}}{2} \\
       &amp;= 1 + \phi
\end{align}
\]</span></p>
<h2 id="数学はもうええ" class="titlepage">数学はもうええ。。。</h2>
<h3 id="コードを見せよ">コードを見せよ！</h3>
<h2 id="簡単な例">簡単な例</h2>
<p>Haskell Reportによると、<code>foldr</code>はこんな感じ</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> foldr f z []     <span class="fu">=</span> z
<span class="ot">&gt;</span> foldr f z (x<span class="fu">:</span>xs) <span class="fu">=</span> f x (foldr f z xs)</code></pre>
<p><code>foldr (+) 0 [1, 2, 3, 4]</code> ≡ <code>1 + 2 + 3 + 4</code> を証明してみよ</p>
<div class="notes">
<pre class="sourceCode haskell"><code class="sourceCode haskell">foldr (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>] <span class="fu">=</span> (<span class="fu">+</span>) <span class="dv">1</span> (foldr (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])
                         <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> foldr (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]
                         <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span> <span class="fu">+</span> foldr (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">3</span>, <span class="dv">4</span>]
                         <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span> <span class="fu">+</span> foldr (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">4</span>]
                         <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">4</span> <span class="fu">+</span> foldr (<span class="fu">+</span>) <span class="dv">0</span> []
                         <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">4</span> <span class="fu">+</span> <span class="dv">0</span>
                         <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">4</span></code></pre>
</div>
<h2 id="もっと一般的に">もっと一般的に</h2>
<p><code>sum</code>と<code>foldr (+) 0</code>の等しさを証明しよう</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foldr f z []     <span class="fu">=</span> z
foldr f z (x<span class="fu">:</span>xs) <span class="fu">=</span> f x (foldr f z xs)</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> sum []           <span class="fu">=</span> <span class="dv">0</span>
<span class="ot">&gt;</span> sum (x<span class="fu">:</span>xs)       <span class="fu">=</span> x <span class="fu">+</span> sum xs</code></pre>
<p>. . .</p>
<p>やり方は帰納法証明みたいな感じになる</p>
<div class="notes">
<pre class="sourceCode haskell"><code class="sourceCode haskell">foldr f <span class="dv">0</span> []     <span class="fu">=</span> <span class="dv">0</span>
                 <span class="fu">=</span> sum []

foldr f <span class="dv">0</span> (x<span class="fu">:</span>xs)   <span class="fu">=</span> f x (foldr f <span class="dv">0</span> xs)
foldr (<span class="fu">+</span>) <span class="dv">0</span> (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">+</span> (foldr (<span class="fu">+</span>) <span class="dv">0</span> (x<span class="fu">:</span>xs))
                   <span class="fu">=</span> x <span class="fu">+</span> sum xs
                   <span class="fu">=</span> sum (x<span class="fu">:</span>xs)</code></pre>
</div>
<h2 id="もっともっと一般的に">もっともっと一般的に</h2>
<p>リストは下記のように考えられる</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>] ≡ <span class="dv">1</span> <span class="fu">:</span> <span class="dv">2</span> <span class="fu">:</span> <span class="dv">3</span> <span class="fu">:</span> <span class="dv">4</span> <span class="fu">:</span> []</code></pre>
<ul>
<li><code>[]</code> は空リスト</li>
<li><code>(:)</code> （コンズ）はリストの先頭に追加する関数</li>
</ul>
<p>. . .</p>
<p>実は<code>foldr</code>は、<code>(:)</code>に<code>f</code>と<code>[]</code>に<code>z</code>を交換するものだ！</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foldr  f  z (<span class="dv">1</span><span class="fu">:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">3</span><span class="fu">:</span><span class="dv">4</span><span class="fu">:</span>[])  <span class="fu">=</span> <span class="dv">1</span> <span class="ot">`f`</span> <span class="dv">2</span> <span class="ot">`f`</span> <span class="dv">3</span> <span class="ot">`f`</span> <span class="dv">4</span> <span class="ot">`f`</span> z
foldr (<span class="fu">+</span>) <span class="dv">0</span> (<span class="dv">1</span><span class="fu">:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">3</span><span class="fu">:</span><span class="dv">4</span><span class="fu">:</span>[])  <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">4</span> <span class="fu">+</span> <span class="dv">0</span>
foldr (<span class="fu">*</span>) <span class="dv">1</span> (<span class="dv">1</span><span class="fu">:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">3</span><span class="fu">:</span><span class="dv">4</span><span class="fu">:</span>[])  <span class="fu">=</span> <span class="dv">1</span> <span class="fu">*</span> <span class="dv">2</span> <span class="fu">*</span> <span class="dv">3</span> <span class="fu">*</span> <span class="dv">4</span> <span class="fu">*</span> <span class="dv">1</span>
foldr (<span class="fu">:</span>) [] (<span class="dv">1</span><span class="fu">:</span><span class="dv">2</span><span class="fu">:</span><span class="dv">3</span><span class="fu">:</span><span class="dv">4</span><span class="fu">:</span>[]) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">:</span> <span class="dv">2</span> <span class="fu">:</span> <span class="dv">3</span> <span class="fu">:</span> <span class="dv">4</span> <span class="fu">:</span> []
  <span class="co">-- ∴ foldr (:) [] ≡ id</span></code></pre>
<p>証明は？</p>
<p>証明は定義による</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foldr f z []     <span class="fu">=</span> z                    <span class="co">-- `[]`と`z`の交換</span>
foldr f z (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="ot">`f`</span> (foldr f z xs) <span class="co">-- `(:)`と`f`の交換</span></code></pre>
<h2 id="命令的なコードでも使える">命令的なコードでも使える</h2>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> main <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   putStrLn <span class="st">&quot;What is your name?&quot;</span>
<span class="ot">&gt;</span>   name <span class="ot">&lt;-</span> getLine
<span class="ot">&gt;</span>   replicateM_ <span class="dv">3</span> <span class="fu">$</span> putStrLn (<span class="st">&quot;Hello &quot;</span> <span class="fu">++</span> name)</code></pre>
<p>. . .</p>
<p>do記法から翻訳すると…</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> main' <span class="fu">=</span>
<span class="ot">&gt;</span>   putStrLn <span class="st">&quot;What is your name?&quot;</span> <span class="fu">&gt;&gt;</span>
<span class="ot">&gt;</span>   getLine                       <span class="fu">&gt;&gt;=</span> \name <span class="ot">-&gt;</span>
<span class="ot">&gt;</span>   replicateM_ <span class="dv">3</span> <span class="fu">$</span> putStrLn (<span class="st">&quot;Hello &quot;</span> <span class="fu">++</span> name)</code></pre>
<p>出力は本当に３回出るか？</p>
<p>（この例は <a href="http://www.haskellforall.com/2013/12/equational-reasoning.html" class="uri">http://www.haskellforall.com/2013/12/equational-reasoning.html</a> による）</p>
<h2 id="ソースコード参照">ソースコード参照</h2>
<div class="notes">
<p>このセッションは出来るだけHaskell Reportのソースコードを使っている。 ただ、Haskell Reportに入っていない場合もある。<code>replicateM_</code>はその一つ。 検索する方法は色々ある、例えば。。。</p>
</div>
<ul>
<li>Haskell Report Standard Prelude <a href="http://www.haskell.org/onlinereport/standard-prelude.html" class="uri">http://www.haskell.org/onlinereport/standard-prelude.html</a></li>
<li>Hoogle <a href="http://www.haskell.org/hoogle/" class="uri">http://www.haskell.org/hoogle/</a></li>
<li>Hayoo <a href="http://hayoo.fh-wedel.de" class="uri">http://hayoo.fh-wedel.de</a></li>
<li>Googleで“hackage <関数名>”を検索してみる</li>
</ul>
<p>. . .</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> replicateM_ n x <span class="fu">=</span> sequence_ (replicate n x)</code></pre>
<h2 id="sequence_を調べると"><code>sequence_</code>を調べると</h2>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> sequence_ ms <span class="fu">=</span> foldr (<span class="fu">&gt;&gt;</span>) (return ()) ms</code></pre>
<p><code>foldr</code>でたーー！</p>
<p>. . .</p>
<p>置換してみよ</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> replicateM_' n x <span class="fu">=</span> foldr (<span class="fu">&gt;&gt;</span>) (return ()) (replicate n x)</code></pre>
<p><code>foldr</code>はもうよく分かっているので、<code>replicate</code>の方をみてみよう</p>
<h2 id="replicateとは"><code>replicate</code>とは</h2>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> replicate n x          <span class="fu">=</span> take n (repeat x)</code></pre>
<p>. . .</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> take n _      <span class="fu">|</span> n <span class="fu">&lt;=</span> <span class="dv">0</span> <span class="fu">=</span> []
<span class="ot">&gt;</span> take _ []              <span class="fu">=</span> []
<span class="ot">&gt;</span> take n (x<span class="fu">:</span>xs)          <span class="fu">=</span> x <span class="fu">:</span> take (n<span class="fu">-</span><span class="dv">1</span>) xs</code></pre>
<p>. . .</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> repeat x               <span class="fu">=</span> xs <span class="kw">where</span> xs <span class="fu">=</span> x<span class="fu">:</span>xs</code></pre>
<p><code>n</code>の値を知らないと<code>take</code>の置換できないので、<code>3</code>を入れる</p>
<div class="notes">
<pre class="sourceCode haskell"><code class="sourceCode haskell">replicate <span class="dv">3</span> x <span class="fu">=</span> take <span class="dv">3</span> (repeat x)
              <span class="fu">=</span> x <span class="fu">:</span> take <span class="dv">2</span> (tail (repeat x))
              <span class="fu">=</span> x <span class="fu">:</span> x <span class="fu">:</span> take <span class="dv">1</span> (tail (repeat x))
              <span class="fu">=</span> x <span class="fu">:</span> x <span class="fu">:</span> x <span class="fu">:</span> take <span class="dv">0</span> (tail (repeat x))
              <span class="fu">=</span> x <span class="fu">:</span> x <span class="fu">:</span> x <span class="fu">:</span> []</code></pre>
</div>
<h2 id="定義を広げる">定義を広げる</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell">replicateM_' <span class="dv">3</span> x <span class="fu">=</span> foldr (<span class="fu">&gt;&gt;</span>) (return ()) (replicate <span class="dv">3</span> x)
replicateM_' <span class="dv">3</span> x <span class="fu">=</span> foldr (<span class="fu">&gt;&gt;</span>) (return ()) (x <span class="fu">:</span> x <span class="fu">:</span> x <span class="fu">:</span> [])</code></pre>
<ul>
<li><code>(:)</code>は、<code>(&gt;&gt;)</code>になる</li>
<li><code>[]</code>は、<code>return ()</code>になる</li>
</ul>
<p>. . .</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">replicateM_' <span class="dv">3</span> x <span class="fu">=</span> x <span class="fu">&gt;&gt;</span> x <span class="fu">&gt;&gt;</span> x <span class="fu">&gt;&gt;</span> return ()</code></pre>
<h2 id="xを置換する"><code>x</code>を置換する</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell">replicateM_' <span class="dv">3</span> x <span class="fu">=</span> x <span class="fu">&gt;&gt;</span> x <span class="fu">&gt;&gt;</span> x <span class="fu">&gt;&gt;</span> return ()
  <span class="kw">where</span> x <span class="fu">=</span> putStrLn (<span class="st">&quot;Hello &quot;</span> <span class="fu">++</span> name)</code></pre>
<p>. . .</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> main'' <span class="fu">=</span>
<span class="ot">&gt;</span>   putStrLn <span class="st">&quot;What is your name?&quot;</span> <span class="fu">&gt;&gt;</span>
<span class="ot">&gt;</span>   getLine                       <span class="fu">&gt;&gt;=</span> \name <span class="ot">-&gt;</span>
<span class="ot">&gt;</span>   putStrLn (<span class="st">&quot;Hello &quot;</span> <span class="fu">++</span> name)   <span class="fu">&gt;&gt;</span> 
<span class="ot">&gt;</span>   putStrLn (<span class="st">&quot;Hello &quot;</span> <span class="fu">++</span> name)   <span class="fu">&gt;&gt;</span> 
<span class="ot">&gt;</span>   putStrLn (<span class="st">&quot;Hello &quot;</span> <span class="fu">++</span> name)   <span class="fu">&gt;&gt;</span> 
<span class="ot">&gt;</span>   return ()</code></pre>
<p>. . .</p>
<p>疲れた。</p>
<h2 id="もっと一般的にできる">もっと一般的にできる？</h2>
<blockquote>
<code>n</code>の値を知らないと<code>take</code>の置換できないので、<code>3</code>を入れる
</blockquote>
<p>と書くとイラっとする。</p>
<p>また、今の証明は<code>3</code>の値としか証明できてない。 <code>4</code>を入れるとまた証明が必要。</p>
<p>もっといい方法あるのでしょうか？</p>
<h2 id="数学的法則">数学的法則</h2>
<p>数学では、分配法則という法則がある。</p>
<p><span class="math">\[
\begin{align}
a \times (b + c) &amp;= a \times b + a \times c \\
(a \times b) + c &amp;= a \times c + b \times c
\end{align}
\]</span></p>
<p>. . .</p>
<p><code>replicateM_</code> に似たような法則を証明できたら、 何の数字を入れても、方程式を「１」について書き直せる。</p>
<p>. . .</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">replicateM_ <span class="dv">0</span>       x <span class="fu">=</span> return ()                          <span class="co">-- 和</span>
replicateM_ (m <span class="fu">+</span> n) x <span class="fu">=</span> replicateM_ m x <span class="fu">&gt;&gt;</span> replicateM_ n x
replicateM_ <span class="dv">1</span>         <span class="fu">=</span> id                                 <span class="co">-- 積</span>
replicateM_ (m <span class="fu">*</span> n)   <span class="fu">=</span> replicateM_ m <span class="fu">.</span> replicateM_ n</code></pre>
<p>. . .</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">replicateM_ <span class="dv">3</span> x <span class="fu">=</span> replicateM_ (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">0</span>) x
                <span class="fu">=</span> replicateM_ <span class="dv">1</span> x <span class="fu">&gt;&gt;</span> replicateM_ <span class="dv">1</span> x <span class="fu">&gt;&gt;</span> replicateM_ <span class="dv">1</span> x <span class="fu">&gt;&gt;</span> return ()
                <span class="fu">=</span> x <span class="fu">&gt;&gt;</span> x <span class="fu">&gt;&gt;</span> x <span class="fu">&gt;&gt;</span> return ()
  <span class="kw">where</span> x <span class="fu">=</span> putStrLn (<span class="st">&quot;Hello &quot;</span> <span class="fu">++</span> name)</code></pre>
<p>どうやって証明する？</p>
<div class="notes">
<p>The non-pointfree version of <code>replicateM_</code> distribution over multiplication is:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">replicateM_ <span class="dv">1</span>       x <span class="fu">=</span> x
replicateM_ (m <span class="fu">*</span> n) x <span class="fu">=</span> replicateM_ m (replicateM_ n x)</code></pre>
</div>
<h2 id="便利な法則を探す">便利な法則を探す</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell">replicateM_ n x <span class="fu">=</span> sequence_ (replicate n x)</code></pre>
<p>この方程式を見ると、分配法則を証明する方法は明らかでない。</p>
<p>ただ、プログラミング的に考えると当たり前でしょう。</p>
<p>. . .</p>
<ul>
<li><code>replicate</code> は、ある値をリストに<code>x</code>回重ねる</li>
<li><code>sequence_</code> は、あるリストをモナド的に順序で行える</li>
</ul>
<p><code>replicate</code>に<code>replicateM_</code>の「分配法則」に似たような法則を使って、 <code>sequence_</code>でその法則の「順序化」できるのでしょうか？</p>
<div class="notes">
<p>まぁ、できなかったらそういうことは言わないからできるでしょう。</p>
</div>
<h2 id="はいできる">はい、できる</h2>
<p>. . .</p>
<h3 id="replicateの分配法則"><code>replicate</code>の「分配法則」</h3>
<pre class="sourceCode haskell"><code class="sourceCode haskell">replicate <span class="dv">0</span>       x <span class="fu">=</span> []                             <span class="co">-- 和</span>
replicate (m <span class="fu">+</span> n) x <span class="fu">=</span> replicate m x <span class="fu">++</span> replicate n x
replicate <span class="dv">1</span>         <span class="fu">=</span> return                         <span class="co">-- 積</span>
replicate (m <span class="fu">*</span> n)   <span class="fu">=</span> replicate m <span class="fu">&lt;=&lt;</span> replicate n</code></pre>
<div class="notes">
<p>The non-pointfree version of <code>replicate</code> distribution over multiplication is:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">replicate <span class="dv">1</span>       x <span class="fu">=</span> [x]
replicate (m <span class="fu">*</span> n) x <span class="fu">=</span> concatMap (replicate m) (replicate n x)</code></pre>
</div>
<h3 id="sequence_の順序化"><code>sequence_</code>の「順序化」</h3>
<pre class="sourceCode haskell"><code class="sourceCode haskell">sequence_ []          <span class="fu">=</span> return ()                    <span class="co">-- 連結　→　順序制御</span>
sequence_ (xs <span class="fu">++</span> ys)  <span class="fu">=</span> sequence_ xs <span class="fu">&gt;&gt;</span> sequence_ ys
sequence_ <span class="fu">.</span> return    <span class="fu">=</span> void <span class="fu">.</span> id                    <span class="co">-- リスト関数　→　普通関数</span>
sequence_ <span class="fu">.</span> (f <span class="fu">&lt;=&lt;</span> g) <span class="fu">=</span> (sequence_ <span class="fu">.</span> f) <span class="fu">.</span> (sequence_ <span class="fu">.</span> g)</code></pre>
<div class="notes">
<p>The non-pointfree version of the <code>sequence_</code> lifting equations is:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">sequence_ [x] <span class="fu">=</span> x <span class="fu">&gt;&gt;</span> return ()
sequence_ (concatMap f (g x)) <span class="fu">=</span> sequence_ (f (sequence_ (g x)))</code></pre>
</div>
<h3 id="replicatem_の分配法則の証明"><code>replicateM_</code>の「分配法則」の証明</h3>
<pre class="sourceCode haskell"><code class="sourceCode haskell">replicateM_ <span class="dv">0</span>       x <span class="fu">=</span> sequence_ (replicate <span class="dv">0</span> x)
                      <span class="fu">=</span> sequence_ []
                      <span class="fu">=</span> return ()

replicateM_ (m <span class="fu">+</span> n) x <span class="fu">=</span> sequence_ (replicate (m <span class="fu">+</span> n) x)
                      <span class="fu">=</span> sequence_ (replicate m x <span class="fu">++</span> replicate n x)
                      <span class="fu">=</span> sequence_ (replicate m x) <span class="fu">&gt;&gt;</span> sequence_ (replicate n x)
                      <span class="fu">=</span> replicateM_ m x <span class="fu">&gt;&gt;</span> replicateM_ n x</code></pre>
<h2 id="必要な証明が増えてきた">必要な証明が増えてきた　☹</h2>
<p>この方程式は証明できた</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">replicateM_ <span class="dv">0</span>       x <span class="fu">=</span> return ()
replicateM_ (m <span class="fu">+</span> n) x <span class="fu">=</span> replicateM_ m x <span class="fu">&gt;&gt;</span> replicateM_ n x
replicateM_ <span class="dv">1</span>         <span class="fu">=</span> id
replicateM_ (m <span class="fu">*</span> n)   <span class="fu">=</span> replicateM_ m <span class="fu">.</span> replicateM_ n</code></pre>
<p>. . .</p>
<p>ただ、その証明をするため、下記の法則を使った</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">replicate <span class="dv">0</span>       x   <span class="fu">=</span> []
replicate (m <span class="fu">+</span> n) x   <span class="fu">=</span> replicate m x <span class="fu">++</span> replicate n x
replicate <span class="dv">1</span>           <span class="fu">=</span> return
replicate (m <span class="fu">*</span> n)     <span class="fu">=</span> replicate m <span class="fu">&lt;=&lt;</span> replicate n
sequence_ []          <span class="fu">=</span> return ()
sequence_ (xs <span class="fu">++</span> ys)  <span class="fu">=</span> sequence_ xs <span class="fu">&gt;&gt;</span> sequence_ ys
sequence_ <span class="fu">.</span> return    <span class="fu">=</span> void <span class="fu">.</span> id
sequence_ <span class="fu">.</span> (f <span class="fu">&lt;=&lt;</span> g) <span class="fu">=</span> (sequence_ <span class="fu">.</span> f) <span class="fu">.</span> (sequence_ <span class="fu">.</span> g)</code></pre>
<p>これも証明しようと思ったら、逆に証明しないといけない方程式は２倍増えた！</p>
<div class="notes">
<p>実はそういうときある。</p>
<p>コードと同じく、 抽象化したら、証明が分かりやすくなるかもしれないし、 他の証明でも使えるかもしれない。 だけど、 逆に抽象化をしすぎてただの仕事になるときもある。 抽象化をするべきか、しない方がいいか、 というのは、自分で判断するしかない。</p>
<p>因に「全部自分で証明しなきゃダメ」とは言わない。 数学もそうだけど、 信頼できる人が「こういう法則あれよ！」と言ってくれたら、 そのまま使ってもいい。</p>
</div>
<div class="notes">
<h3 id="replicateの証明"><code>replicate</code>の証明</h3>
<p>この証明は <a href="http://www.haskellforall.com/2013/12/equational-reasoning.html" class="uri">http://www.haskellforall.com/2013/12/equational-reasoning.html</a> による</p>
<p>証明したいこと</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">replicate  <span class="dv">0</span>      x <span class="fu">=</span> []
replicate (m <span class="fu">+</span> n) x <span class="fu">=</span> replicate m x <span class="fu">++</span> replicate n x
replicate  <span class="dv">1</span>      x <span class="fu">=</span> [x]
replicate (m <span class="fu">*</span> n) x <span class="fu">=</span> concatMap (replicate m) (replicate n x)</code></pre>
<p>参考のため</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">concatMap<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> [b]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
concatMap f <span class="fu">=</span> foldr ((<span class="fu">++</span>) <span class="fu">.</span> f) []</code></pre>
<p>証明</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">replicate <span class="dv">0</span> x       <span class="fu">=</span> take <span class="dv">0</span> (repeat x)                           <span class="co">-- replicateの定義</span>
                    <span class="fu">=</span> []                                          <span class="co">-- takeの定義</span>

replicate <span class="dv">1</span> x       <span class="fu">=</span> take <span class="dv">1</span> (repeat x)                           <span class="co">-- replicateの定義</span>
                    <span class="fu">=</span> take <span class="dv">1</span> (x<span class="fu">:</span>repeat x)                         <span class="co">-- repeatの定義</span>
                    <span class="fu">=</span> x<span class="fu">:</span>take <span class="dv">0</span> (repeat x)                         <span class="co">-- takeの定義</span>
                    <span class="fu">=</span> x<span class="fu">:</span>[] <span class="fu">=</span> [x]                                  <span class="co">-- takeの定義</span>

<span class="co">-- 和、m = 0</span>
replicate (m <span class="fu">+</span> n) x <span class="fu">=</span> take (m <span class="fu">+</span> n) (repeat x)                     <span class="co">-- replicateの定義</span>
                    <span class="fu">=</span> take (<span class="dv">0</span> <span class="fu">+</span> n) (repeat x)                     <span class="co">-- 推定： m = 0</span>
                    <span class="fu">=</span> take n (repeat x)                           <span class="co">-- 0 + n = n</span>
                    <span class="fu">=</span> [] <span class="fu">++</span> take n (repeat x)                     <span class="co">-- (++)の定義　（逆）</span>
                    <span class="fu">=</span> take <span class="dv">0</span> (repeat x) <span class="fu">++</span> take n (repeat x)      <span class="co">-- takeの定義　（逆）</span>
                    <span class="fu">=</span> take m (repeat x) <span class="fu">++</span> take n (repeat x)      <span class="co">-- m = 0</span>
                    <span class="fu">=</span> replicate m x <span class="fu">++</span> replicate n x              <span class="co">-- replicateの定義　（逆）</span>

<span class="co">-- 和、m &gt; 0 (m = 1 + m' where m' &gt;= 0)</span>
replicate (m <span class="fu">+</span> n) x <span class="fu">=</span> take (m <span class="fu">+</span> n) (repeat x)                     <span class="co">-- replicateの定義</span>
                    <span class="fu">=</span> take (<span class="dv">1</span> <span class="fu">+</span> m' <span class="fu">+</span> n) (repeat x)                <span class="co">-- 推定： m = 1 + m'</span>
                    <span class="fu">=</span> take (<span class="dv">1</span> <span class="fu">+</span> m' <span class="fu">+</span> n) (x<span class="fu">:</span>repeat x)              <span class="co">-- repeatの定義</span>
                    <span class="fu">=</span> x<span class="fu">:</span>take (m' <span class="fu">+</span> n) (repeat x)                  <span class="co">-- takeの定義</span>
                    <span class="fu">=</span> x<span class="fu">:</span>replicate (m' <span class="fu">+</span> n) x                      <span class="co">-- replicateの定義（逆）</span>
                    <span class="fu">=</span> x<span class="fu">:</span>(replicate m' x <span class="fu">++</span> replicate n x)         <span class="co">-- 帰納法</span>
                    <span class="fu">=</span> (x<span class="fu">:</span>replicate m' x) <span class="fu">++</span> replicate n x         <span class="co">-- (++)の定義　（逆）</span>
                    <span class="fu">=</span> (x<span class="fu">:</span>take m' (repeat x)) <span class="fu">++</span> replicate n x     <span class="co">-- replicateの定義</span>
                    <span class="fu">=</span> take (<span class="dv">1</span> <span class="fu">+</span> m') (repeat x) <span class="fu">++</span> replicate n x   <span class="co">-- takeの定義　（逆）</span>
                    <span class="fu">=</span> replicate (<span class="dv">1</span> <span class="fu">+</span> m') x <span class="fu">++</span> replicate n x       <span class="co">-- replicateの定義（逆）</span>
                    <span class="fu">=</span> replicate m x <span class="fu">++</span> replicate n x              <span class="co">-- m = 1 + m'（逆）</span>

<span class="co">-- 積、n = 0</span>
replicate (m <span class="fu">*</span> n) x <span class="fu">=</span> replicate <span class="dv">0</span> x                               <span class="co">-- 推定： n = 0</span>
                    <span class="fu">=</span> []                                          <span class="co">-- replicate 0 x = []</span>
                    <span class="fu">=</span> foldr ((<span class="fu">++</span>) <span class="fu">.</span> replicate m) [] []            <span class="co">-- foldrの定義（逆）</span>
                    <span class="fu">=</span> concatMap (replicate m) []                  <span class="co">-- concatMapの定義（逆）</span>
                    <span class="fu">=</span> concatMap (replicate m) (replicate <span class="dv">0</span> x)     <span class="co">-- replicate 0 x = [] （逆）</span>
                    <span class="fu">=</span> concatMap (replicate m) (replicate n x)     <span class="co">-- n = 0 （逆）</span>

<span class="co">-- 積、n &gt; 0 (n = 1 + n' where n' &gt;= 0)</span>
replicate (m <span class="fu">*</span> n) x <span class="fu">=</span> replicate (m <span class="fu">*</span> (<span class="dv">1</span> <span class="fu">+</span> n')) x                  <span class="co">-- 推定： n = 1 + n'</span>
                    <span class="fu">=</span> replicate (m <span class="fu">+</span> m <span class="fu">*</span> n') x                    <span class="co">-- m * (1 + n') = m + m * n'</span>
                    <span class="fu">=</span> replicate m x <span class="fu">++</span> replicate (m <span class="fu">*</span> n') x       <span class="co">-- replicateの「分配法則」（和）</span>
                    <span class="fu">=</span> replicate m x <span class="fu">++</span> concatMap (replicate m) (replicate n' x)
                                                                  <span class="co">-- 帰納法</span>
                    <span class="fu">=</span> replicate m x <span class="fu">++</span> foldr ((<span class="fu">++</span>) <span class="fu">.</span> replicate m) [] (replicate n' x)
                                                                  <span class="co">-- concatMapの定義</span>
                    <span class="fu">=</span> foldr ((<span class="fu">++</span>) <span class="fu">.</span> replicate m)) [] (x<span class="fu">:</span>replicate n' x)
                                                                  <span class="co">-- foldrの定義（逆）</span>
                    <span class="fu">=</span> concatMap (replicate m) (x<span class="fu">:</span>replicate n' x)  <span class="co">-- concatMapの定義（逆）</span>
                    <span class="fu">=</span> concatMap (replicate m) (x<span class="fu">:</span>take n' (repeat x))
                                                                  <span class="co">-- replicateの定義</span>
                    <span class="fu">=</span> concatMap (replicate m) (take (<span class="dv">1</span> <span class="fu">+</span> n') (x<span class="fu">:</span>repeat x))
                                                                  <span class="co">-- takeの定義（逆）</span>
                    <span class="fu">=</span> concatMap (replicate m) (take n (x<span class="fu">:</span>repeat x))
                                                                  <span class="co">-- n = 1 + n' （逆）</span>
                    <span class="fu">=</span> concatMap (replicate m) (take n (repeat x)) <span class="co">-- repeatの定義（逆）</span>
                    <span class="fu">=</span> concatMap (replicate m) (replicate n x)     <span class="co">-- replicateの定義（逆）</span></code></pre>
<h3 id="sequence_の証明"><code>sequence_</code>の証明</h3>
<p>証明したいこと</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">sequence_ []                  <span class="fu">=</span> return ()
sequence_ (xs <span class="fu">++</span> ys)          <span class="fu">=</span> sequence_ xs <span class="fu">&gt;&gt;</span> sequence_ ys
sequence_ [x]                 <span class="fu">=</span> x <span class="fu">&gt;&gt;</span> return ()
sequence_ (concatMap f (g x)) <span class="fu">=</span> sequence_ (f (sequence_ (g x)))</code></pre>
<p>証明</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">sequence_ []  <span class="fu">=</span> foldr (<span class="fu">&gt;&gt;</span>) (return ()) [] <span class="co">-- sequence_の定義</span>
              <span class="fu">=</span> return ()                 <span class="co">-- foldrの定義 (foldr f z [] = z)</span>

sequence_ [x] <span class="fu">=</span> foldr (<span class="fu">&gt;&gt;</span>) (return ()) [x]     <span class="co">-- sequence_の定義</span>
              <span class="fu">=</span> x <span class="fu">&gt;&gt;</span> foldr (<span class="fu">&gt;&gt;</span>) (return ()) [] <span class="co">-- foldrの定義</span>
              <span class="fu">=</span> x <span class="fu">&gt;&gt;</span> return ()                 <span class="co">-- foldrの定義</span>

<span class="co">-- 和、xs = []</span>
sequence_ (xs <span class="fu">++</span> ys) <span class="fu">=</span> sequence_ ([] <span class="fu">++</span> ys)        <span class="co">-- 推定： xs = []</span>
                     <span class="fu">=</span> sequence_ ys                <span class="co">-- (++)の定義</span>
                     <span class="fu">=</span> return () <span class="fu">&gt;&gt;</span> sequence_ ys   <span class="co">-- return () &gt;&gt; m = m　（逆）</span>
                     <span class="fu">=</span> sequence_ [] <span class="fu">&gt;&gt;</span> sequence_ ys <span class="co">-- sequence_ [] = return ()　（逆）</span>
                     <span class="fu">=</span> sequence_ xs <span class="fu">&gt;&gt;</span> sequence_ ys <span class="co">-- xs = []</span>

<span class="co">-- 和、xs = x:xs' where xs' is a (possibly empty) list</span>
sequence_ (xs <span class="fu">++</span> ys) <span class="fu">=</span> sequence_ (x<span class="fu">:</span>xs' <span class="fu">++</span> ys)                        <span class="co">-- 推定： xs = x:xs'</span>
                     <span class="fu">=</span> foldr (<span class="fu">&gt;&gt;</span>) (return ()) (x<span class="fu">:</span>xs' <span class="fu">++</span> ys)           <span class="co">-- sequence_の定義</span>
                     <span class="fu">=</span> x <span class="fu">&gt;&gt;</span> foldr (<span class="fu">&gt;&gt;</span>) (return ()) (xs' <span class="fu">++</span> ys)        <span class="co">-- foldrの定義</span>
                     <span class="fu">=</span> x <span class="fu">&gt;&gt;</span> sequence_ xs' <span class="fu">&gt;&gt;</span> sequence_ ys             <span class="co">-- 帰納法</span>
                     <span class="fu">=</span> foldr (<span class="fu">&gt;&gt;</span>) (return ()) (x<span class="fu">:</span>xs') <span class="fu">&gt;&gt;</span> sequence_ ys <span class="co">-- foldrの定義　（逆）</span>
                     <span class="fu">=</span> sequence_ (x<span class="fu">:</span>xs') <span class="fu">&gt;&gt;</span> sequence_ ys              <span class="co">-- sequence_の定義　（逆）</span>
                     <span class="fu">=</span> sequence_ xs <span class="fu">&gt;&gt;</span> sequence_ ys                   <span class="co">-- xs = x:xs'　（逆）</span>


<span class="co">-- 積、g x = []</span>
sequence_ (concatMap f (g x)) <span class="fu">=</span> sequence_ (foldr ((<span class="fu">++</span>) <span class="fu">.</span> f) [] (g x))  <span class="co">-- concatMapの定義</span>
                              <span class="fu">=</span> sequence_ (foldr ((<span class="fu">++</span>) <span class="fu">.</span> f) [] [])     <span class="co">-- 推定： g x = []</span>
                              <span class="fu">=</span> sequence_ []                           <span class="co">-- foldrの定義</span>
                              <span class="fu">=</span> return ()                              <span class="co">-- sequence [] = return ()</span>

                              <span class="fu">=</span> sequence_ (((<span class="fu">++</span>) <span class="fu">.</span> f) [] [])
                              <span class="fu">=</span> sequence_ (f [] <span class="fu">++</span> [])
                              <span class="fu">=</span> sequence_ (f [])
                              <span class="fu">=</span> sequence_ f [x'] <span class="fu">&gt;&gt;</span> sequence_ []

<span class="co">-- 積、f x = []</span>
sequence_ (concatMap f (g x)) <span class="fu">=</span> sequence_ (concat (map f (g x)))              <span class="co">-- concatMap = concat . map</span>
                              <span class="fu">=</span> sequence_ (foldr ((<span class="fu">++</span>) <span class="fu">.</span> f) [] (g x))         <span class="co">-- concatMapの定義</span>
                              <span class="fu">=</span> sequence_ (foldr (\a b <span class="ot">-&gt;</span> f a <span class="fu">++</span> b) [] (g x)) <span class="co">-- pointful式</span>
                              <span class="fu">=</span> sequence_ (foldr (\_ b <span class="ot">-&gt;</span> [] <span class="fu">++</span> b) [] (g x))  <span class="co">-- f x = []</span>
                              <span class="fu">=</span> sequence_ []


                              <span class="fu">=</span> sequence_ (foldr (<span class="fu">++</span>) [] (foldr f [] (g x)))   <span class="co">-- foldr (f . g) x = foldr f x . foldr g x</span>


                              <span class="fu">=</span> sequence_ (concat (map f []))    <span class="co">-- g x = []</span>
                              <span class="fu">=</span> sequence_ (concat [])            <span class="co">-- mapの定義</span>
                              <span class="fu">=</span> sequence_ []                     <span class="co">-- concatの定義</span>


sequence_ (foldr ((<span class="fu">++</span>) <span class="fu">.</span> f) [] (g x))  <span class="co">-- concatMapの定義</span>
                              <span class="fu">=</span> sequence_ 


                              <span class="fu">=</span> sequence_ (foldr (<span class="fu">++</span>) [] (foldr f [] (g x)))   <span class="co">-- foldr (f . g) x = foldr f x . foldr g x</span>
                              <span class="fu">=</span> sequence_ (foldr (<span class="fu">++</span>) [] (foldr f [] ([x']<span class="fu">:</span>[]))) <span class="co">-- 推定： g x = [x']:[]</span>
                              <span class="fu">=</span> sequence_ (foldr (<span class="fu">++</span>) [] (f [x'] []))          <span class="co">-- foldrの定義</span>
                              <span class="fu">=</span> sequence_ ((f [x'] []) <span class="fu">++</span> [])                  <span class="co">-- foldrの定義</span>
                              <span class="fu">=</span> sequence_ (f [x'] []) <span class="fu">&gt;&gt;</span> sequence_ []
                              <span class="fu">=</span> sequence_ (f [x'] []) <span class="fu">&gt;&gt;</span> return ()

型

<span class="ot">f ::</span> m1 () <span class="ot">-&gt;</span> [m a1]
<span class="ot">g ::</span> a     <span class="ot">-&gt;</span> [m1 ()]
<span class="ot">x ::</span> a

foldr (<span class="fu">&gt;&gt;</span>) (return ()) (f (foldr (<span class="fu">&gt;&gt;</span>) (return ()) (g x)))
sequence_ (f (foldr (<span class="fu">&gt;&gt;</span>) (return ()) (g x)))

<span class="fu">=</span> sequence_ (f (sequence_ (g x)))

sequence_ ms <span class="fu">=</span> foldr (<span class="fu">&gt;&gt;</span>) (return ()) ms
concatMap<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> [b]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
concatMap f <span class="fu">=</span> foldr ((<span class="fu">++</span>) <span class="fu">.</span> f) []
map _ []     <span class="fu">=</span> []
map f (x<span class="fu">:</span>xs) <span class="fu">=</span> f x <span class="fu">:</span> map f xs</code></pre>
</div>
<h2 id="何の価値" class="titlepage">何の価値？</h2>
<div class="notes">
<p>学校でこういう事を勉強したときに、「めんどくせぇ〜」としか思わなかった。 何でわざわざプログラミングでするのか？</p>
</div>
<h2 id="正確さを証明できること" class="titlepage">正確さを証明できること</h2>
<h3 id="あるいはある法則に従っていることを証明できること">あるいは、ある法則に従っていることを証明できること</h3>
<h2 id="最適化をできること" class="titlepage">最適化をできること</h2>
<h3 id="最適化されたバージョンは元のバージョンに等しいと証明すること">＝最適化されたバージョンは元のバージョンに等しいと証明すること</h3>
<div class="notes">
<p>証明できたら、コンパイル時に自動的に最適化を行える！</p>
</div>
<h2 id="ドキュメンテーション" class="titlepage">ドキュメンテーション</h2>
<h3 id="hackageではよく使われている">Hackageではよく使われている</h3>
<h2 id="難しいコンセプトを理解すること" class="titlepage">難しいコンセプトを理解すること</h2>
<h3 id="分からないモナドがあったら等式推論をやってみ">分からないモナドがあったら等式推論をやってみ！</h3>
<h2 id="なれたら実は楽しい" class="titlepage">なれたら実は楽しい！</h2>
<h2 id="等式推論やってみたいアドバイスとコツ">等式推論やってみたい！アドバイスとコツ</h2>
<ul>
<li>自分のコードに便利な法則を探す
<ul>
<li>特にtypeclass</li>
</ul></li>
<li>ドキュメンテーションに書いてある方程式を法則として使う</li>
<li>「抽象化できるか？」を考えながら証明する</li>
<li>証明ができたらその法則をドキュメンテーションに書く！
<ul>
<li>証明自体はアップしなくていい</li>
<li>それでもしたいと思ったら、コメントか、ブログに書いたらいいでしょう</li>
</ul></li>
<li>自分のモナド、レンズ、パイプ等を書くとき、法則を証明しよう！</li>
</ul>
<h2 id="参考文献">参考文献</h2>
<ul>
<li>Gabriel Gonzalezさん (Tekmo)　がよく使っている
<ul>
<li>Equational Reasoning <a href="http://www.haskellforall.com/2013/12/equational-reasoning.html" class="uri">http://www.haskellforall.com/2013/12/equational-reasoning.html</a></li>
<li>Equational Reasoning at Scale <a href="http://www.haskellforall.com/2014/07/equational-reasoning-at-scale.html" class="uri">http://www.haskellforall.com/2014/07/equational-reasoning-at-scale.html</a></li>
</ul></li>
<li>Pearls of Functional Algorithm Design, Richard Bird
<ul>
<li><a href="http://www.amazon.co.jp/Pearls-Functional-Algorithm-Design-Richard-ebook/dp/B009019VUK/ref=sr_1_1?ie=UTF8&amp;qid=1409933562&amp;sr=8-1&amp;keywords=pearls+of+functional+algorithm+design" class="uri">http://www.amazon.co.jp/Pearls-Functional-Algorithm-Design-Richard-ebook/dp/B009019VUK/ref=sr_1_1?ie=UTF8&amp;qid=1409933562&amp;sr=8-1&amp;keywords=pearls+of+functional+algorithm+design</a></li>
</ul></li>
<li>Typeclassopedia <a href="http://www.haskell.org/haskellwiki/Typeclassopedia" class="uri">http://www.haskell.org/haskellwiki/Typeclassopedia</a>
<ul>
<li>等式推論の話自体はないけど、Typeclass法則は全部方程式で書いてて、等式推論で証明するのはいい練習になるかもしれない</li>
</ul></li>
</ul>
<h2 id="終" class="titlepage">終</h2>
<p>. . .</p>
<h3 id="ありがとうございました">ありがとうございました</h3>
<div class="notes">
<h2 id="例stateモナド">例　Stateモナド</h2>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">State</span> s a <span class="fu">=</span> <span class="dt">State</span> {<span class="ot"> runState ::</span> s <span class="ot">-&gt;</span> (a, s) }
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">State</span> s) <span class="kw">where</span>
<span class="ot">&gt;</span>     return a <span class="fu">=</span> <span class="dt">State</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> (a, s)
<span class="ot">&gt;</span>     m <span class="fu">&gt;&gt;=</span> k  <span class="fu">=</span> <span class="dt">State</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">let</span>
<span class="ot">&gt;</span>         (a, s') <span class="fu">=</span> runState m s
<span class="ot">&gt;</span>         <span class="kw">in</span> runState (k a) s'
<span class="ot">&gt;</span> get   <span class="fu">=</span> <span class="dt">State</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> (s, s)
<span class="ot">&gt;</span> put s <span class="fu">=</span> <span class="dt">State</span> <span class="fu">$</span> \_ <span class="ot">-&gt;</span> ((), s)</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> tick <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   n <span class="ot">&lt;-</span> get
<span class="ot">&gt;</span>   put <span class="fu">$</span> n <span class="fu">+</span> <span class="dv">1</span>
<span class="ot">&gt;</span>   return n</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell">tick <span class="fu">=</span> get <span class="fu">&gt;&gt;=</span> \n <span class="ot">-&gt;</span> put (n <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">&gt;&gt;</span> return n            <span class="co">-- do記法翻訳</span>
     <span class="fu">=</span> get <span class="fu">&gt;&gt;=</span> \n <span class="ot">-&gt;</span> put (n <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> return n    <span class="co">-- (&gt;&gt;)の定義</span>
     <span class="fu">=</span> get <span class="fu">&gt;&gt;=</span> \n <span class="ot">-&gt;</span> put (n <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> (n, s) <span class="co">-- returnの定義</span>
     <span class="fu">=</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> (s, s)) <span class="fu">&gt;&gt;=</span> \n <span class="ot">-&gt;</span> put (n <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> (n, s)) <span class="co">-- getの定義</span>
     <span class="fu">=</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> (s, s)) <span class="fu">&gt;&gt;=</span> \n <span class="ot">-&gt;</span> <span class="dt">State</span> (\_ <span class="ot">-&gt;</span> ((), n <span class="fu">+</span> <span class="dv">1</span>)) <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> (n, s)) <span class="co">-- putの定義</span>
     <span class="fu">=</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> <span class="kw">let</span> (a, s') <span class="fu">=</span> runState (<span class="dt">State</span> (\s <span class="ot">-&gt;</span> (s, s))) s
                    <span class="kw">in</span>  runState(\n <span class="ot">-&gt;</span> <span class="dt">State</span> (\_ <span class="ot">-&gt;</span> ((), n <span class="fu">+</span> <span class="dv">1</span>)) <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> (n, s)) a) s') <span class="co">-- (&gt;&gt;=)の定義</span>
     <span class="fu">=</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> <span class="kw">let</span> (a, s') <span class="fu">=</span> (s, s)
                    <span class="kw">in</span> runState(\n <span class="ot">-&gt;</span> <span class="dt">State</span> (\_ <span class="ot">-&gt;</span> ((), n <span class="fu">+</span> <span class="dv">1</span>)) <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> (n, s)) a) s' <span class="co">-- runStateにsを適用する</span>
     <span class="fu">=</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> runState (\n <span class="ot">-&gt;</span> <span class="dt">State</span> (\_ <span class="ot">-&gt;</span> ((), n <span class="fu">+</span> <span class="dv">1</span>)) <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> (n, s)) s) s</code></pre>
</div>

<div class="tagsinfo">Tagged with: <a href="../tags/functional-programming.html">functional-programming</a>, <a href="../tags/equational-reasoning.html">equational-reasoning</a>, <a href="../tags/haskell.html">haskell</a>, <a href="../tags/talks.html">talks</a>, <a href="../tags/%E6%97%A5%E6%9C%AC%E8%AA%9E.html">日本語</a></div>

        </div>
        <div id="footer">
            Copyright © 2012-2014 Daniel P. Wright.
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
        </div>
    </body>
</html>
